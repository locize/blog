{"meta":{"title":"locize - localization as a service","subtitle":null,"description":"Bridging the gap between translation and development.","author":"inweso GmbH","url":"http://blog.locize.com","root":"/"},"pages":[{"title":"Page Not Found","date":"2021-04-07T14:32:55.141Z","updated":"2021-04-07T14:32:55.141Z","comments":false,"path":"/404.html","permalink":"http://blog.locize.com/404.html","excerpt":"","text":"Sorry, but the page you were trying to view does not exist --- perhaps you can try searching for it below. var GOOG_FIXURL_LANG = 'en'; var GOOG_FIXURL_SITE = 'https://blog.locize.com'"}],"posts":[{"title":"How to properly internationalize a React application using i18next","slug":"2021-04-14-how-to-internationalize-react-i18next","date":"2021-04-13T22:00:00.000Z","updated":"2021-04-14T13:13:53.455Z","comments":true,"path":"2021-04-14-how-to-internationalize-react-i18next/","link":"","permalink":"http://blog.locize.com/2021-04-14-how-to-internationalize-react-i18next/","excerpt":"","text":"Overcoming the language barrier for users who use your software is an important topic. English is no longer the universal language of the internet. As of March 2020, only 25.9% of internet users were English speakers. The chances are high that your users will skip past your website if non-localised. Therefore, without a multilingual website you might missing out on a large share of potential users. In the JavaScript ecosystem, there are a lot of internationalization frameworks. Here you can find some details about some JavaScript internationalization frameworks. In this article, we will be using the i18next framework to internationalize a React.js app. So first of all: &quot;Why i18next?&quot;When it comes to React localization. One of the most popular is i18next with it&#39;s react extension react-i18next, and for good reasons: i18next was created in late 2011. It&#39;s older than most of the libraries you will use nowadays, including your main frontend technology (react, vue, ...). ‚û°Ô∏è sustainable Based on how long i18next already is available open source, there is no real i18n case that could not be solved with i18next. ‚û°Ô∏è mature i18next can be used in any javascript (and a few non-javascript - .net, elm, iOS, android, ruby, ...) environment, with any UI framework, with any i18n format, ... the possibilities are endless. ‚û°Ô∏è extensible There is a plenty of features and possibilities you&#39;ll get with i18next compared to other regular 18n frameworks. ‚û°Ô∏è rich Here you can find more information about why i18next is special. Let&#39;s get into it...PrerequisitesMake sure you have Node.js and npm installed. It&#39;s best, if you have some experience with simple HTML, JavaScript and basic React.js, before jumping to react-i18next. Getting startedTake your own React project or create a new one, i.e. with create-react-app. npx create-react-app my-app We are going to adapt the app to detect the language according to the user‚Äôs preference. And we will create a language switcher to make the content change between different languages. Let&#39;s install some i18next dependencies: i18next react-i18next i18next-browser-languagedetector npm install i18next react-i18next i18next-browser-languagedetector Let&#39;s prepare an i18n.js file: 12345678910111213141516171819202122232425262728import i18n from &#x27;i18next&#x27;;import &#123; initReactI18next &#125; from &#x27;react-i18next&#x27;;import LanguageDetector from &#x27;i18next-browser-languagedetector&#x27;;i18n // detect user language // learn more: https://github.com/i18next/i18next-browser-languageDetector .use(LanguageDetector) // pass the i18n instance to react-i18next. .use(initReactI18next) // init i18next // for all options read: https://www.i18next.com/overview/configuration-options .init(&#123; debug: true, fallbackLng: &#x27;en&#x27;, interpolation: &#123; escapeValue: false, // not needed for react as it escapes by default &#125;, resources: &#123; en: &#123; translation: &#123; // here we will place our translations... &#125; &#125; &#125; &#125;);export default i18n; Let&#39;s import that file somewhere in our index.js file: 1234567891011121314import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;import &#x27;./index.css&#x27;;import App from &#x27;./App&#x27;;// import i18n (needs to be bundled ;))import &#x27;./i18n&#x27;;ReactDOM.render( &lt;React.StrictMode&gt; &lt;App /&gt; &lt;/React.StrictMode&gt;, document.getElementById(&#x27;root&#x27;)); Now let&#39;s try to move some hard coded text out to the translations. We have used the Trans component for the first text and the useTranslation hook for the second text: 123456789101112131415161718192021222324252627282930import logo from &#x27;./logo.svg&#x27;;import &#x27;./App.css&#x27;;import &#123; useTranslation, Trans &#125; from &#x27;react-i18next&#x27;;function App() &#123; const &#123; t &#125; = useTranslation(); return ( &lt;div className=&quot;App&quot;&gt; &lt;header className=&quot;App-header&quot;&gt; &lt;img src=&#123;logo&#125; className=&quot;App-logo&quot; alt=&quot;logo&quot; /&gt; &lt;p&gt; &lt;Trans i18nKey=&quot;description.part1&quot;&gt; Edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload. &lt;/Trans&gt; &lt;/p&gt; &lt;a className=&quot;App-link&quot; href=&quot;https://reactjs.org&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; &gt; &#123;t(&#x27;description.part2&#x27;)&#125; &lt;/a&gt; &lt;/header&gt; &lt;/div&gt; );&#125;export default App; The texts are now part of the translation resources: 12345678910111213141516171819202122232425262728293031import i18n from &#x27;i18next&#x27;;import &#123; initReactI18next &#125; from &#x27;react-i18next&#x27;;import LanguageDetector from &#x27;i18next-browser-languagedetector&#x27;;i18n // detect user language // learn more: https://github.com/i18next/i18next-browser-languageDetector .use(LanguageDetector) // pass the i18n instance to react-i18next. .use(initReactI18next) // init i18next // for all options read: https://www.i18next.com/overview/configuration-options .init(&#123; debug: true, fallbackLng: &#x27;en&#x27;, interpolation: &#123; escapeValue: false, // not needed for react as it escapes by default &#125;, resources: &#123; en: &#123; translation: &#123; description: &#123; part1: &#x27;Edit &lt;1&gt;src/App.js&lt;/1&gt; and save to reload.&#x27;, part2: &#x27;Learn React&#x27; &#125; &#125; &#125; &#125; &#125;);export default i18n; Language SwitcherNow let&#39;s define a language switcher: 123456789101112131415161718192021222324252627282930313233343536373839404142import logo from &#x27;./logo.svg&#x27;;import &#x27;./App.css&#x27;;import &#123; useTranslation, Trans &#125; from &#x27;react-i18next&#x27;;const lngs = &#123; en: &#123; nativeName: &#x27;English&#x27; &#125;, de: &#123; nativeName: &#x27;Deutsch&#x27; &#125;&#125;;function App() &#123; const &#123; t, i18n &#125; = useTranslation(); return ( &lt;div className=&quot;App&quot;&gt; &lt;header className=&quot;App-header&quot;&gt; &lt;img src=&#123;logo&#125; className=&quot;App-logo&quot; alt=&quot;logo&quot; /&gt; &lt;div&gt; &#123;Object.keys(lngs).map((lng) =&gt; ( &lt;button key=&#123;lng&#125; style=&#123;&#123; fontWeight: i18n.language === lng ? &#x27;bold&#x27; : &#x27;normal&#x27; &#125;&#125; type=&quot;submit&quot; onClick=&#123;() =&gt; i18n.changeLanguage(lng)&#125;&gt; &#123;lngs[lng].nativeName&#125; &lt;/button&gt; ))&#125; &lt;/div&gt; &lt;p&gt; &lt;Trans i18nKey=&quot;description.part1&quot;&gt; Edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload. &lt;/Trans&gt; &lt;/p&gt; &lt;a className=&quot;App-link&quot; href=&quot;https://reactjs.org&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; &gt; &#123;t(&#x27;description.part2&#x27;)&#125; &lt;/a&gt; &lt;/header&gt; &lt;/div&gt; );&#125;export default App; And also add some translations for the new language: 123456789101112131415161718192021222324252627282930313233343536373839import i18n from &#x27;i18next&#x27;;import &#123; initReactI18next &#125; from &#x27;react-i18next&#x27;;import LanguageDetector from &#x27;i18next-browser-languagedetector&#x27;;i18n // detect user language // learn more: https://github.com/i18next/i18next-browser-languageDetector .use(LanguageDetector) // pass the i18n instance to react-i18next. .use(initReactI18next) // init i18next // for all options read: https://www.i18next.com/overview/configuration-options .init(&#123; debug: true, fallbackLng: &#x27;en&#x27;, interpolation: &#123; escapeValue: false, // not needed for react as it escapes by default &#125;, resources: &#123; en: &#123; translation: &#123; description: &#123; part1: &#x27;Edit &lt;1&gt;src/App.js&lt;/1&gt; and save to reload.&#x27;, part2: &#x27;Learn React&#x27; &#125; &#125; &#125;, de: &#123; translation: &#123; description: &#123; part1: &#x27;√Ñndere &lt;1&gt;src/App.js&lt;/1&gt; und speichere um neu zu laden.&#x27;, part2: &#x27;Lerne React&#x27; &#125; &#125; &#125; &#125; &#125;);export default i18n; ü•≥ Awesome, you&#39;ve just created your first language switcher! Thanks to i18next-browser-languagedetector now it tries to detect the browser language and automatically use that language if you&#39;ve provided the translations for it. The manually selected language in the language switcher is persistet in the localStorage, next time you visit the page, that language is used as preferred language. Interpolation and Pluralizationi18next goes beyond just providing the standard i18n features. But for sure it&#39;s able to handle plurals and interpolation. Let&#39;s count each time the language gets changed: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import logo from &#x27;./logo.svg&#x27;;import &#x27;./App.css&#x27;;import &#123; useTranslation, Trans &#125; from &#x27;react-i18next&#x27;;import &#123; useState &#125; from &#x27;react&#x27;;const lngs = &#123; en: &#123; nativeName: &#x27;English&#x27; &#125;, de: &#123; nativeName: &#x27;Deutsch&#x27; &#125;&#125;;function App() &#123; const &#123; t, i18n &#125; = useTranslation(); const [count, setCounter] = useState(0); return ( &lt;div className=&quot;App&quot;&gt; &lt;header className=&quot;App-header&quot;&gt; &lt;img src=&#123;logo&#125; className=&quot;App-logo&quot; alt=&quot;logo&quot; /&gt; &lt;div&gt; &#123;Object.keys(lngs).map((lng) =&gt; ( &lt;button key=&#123;lng&#125; style=&#123;&#123; fontWeight: i18n.language === lng ? &#x27;bold&#x27; : &#x27;normal&#x27; &#125;&#125; type=&quot;submit&quot; onClick=&#123;() =&gt; &#123; i18n.changeLanguage(lng); setCounter(count + 1); &#125;&#125;&gt; &#123;lngs[lng].nativeName&#125; &lt;/button&gt; ))&#125; &lt;/div&gt; &lt;p&gt; &lt;i&gt;&#123;t(&#x27;counter&#x27;, &#123; count &#125;)&#125;&lt;/i&gt; &lt;/p&gt; &lt;p&gt; &lt;Trans i18nKey=&quot;description.part1&quot;&gt; Edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload. &lt;/Trans&gt; &lt;/p&gt; &lt;a className=&quot;App-link&quot; href=&quot;https://reactjs.org&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; &gt; &#123;t(&#x27;description.part2&#x27;)&#125; &lt;/a&gt; &lt;/header&gt; &lt;/div&gt; );&#125;export default App; ...and extending the translation resources: 12345678910111213141516171819202122232425262728293031323334353637383940414243import i18n from &#x27;i18next&#x27;;import &#123; initReactI18next &#125; from &#x27;react-i18next&#x27;;import LanguageDetector from &#x27;i18next-browser-languagedetector&#x27;;i18n // detect user language // learn more: https://github.com/i18next/i18next-browser-languageDetector .use(LanguageDetector) // pass the i18n instance to react-i18next. .use(initReactI18next) // init i18next // for all options read: https://www.i18next.com/overview/configuration-options .init(&#123; debug: true, fallbackLng: &#x27;en&#x27;, interpolation: &#123; escapeValue: false, // not needed for react as it escapes by default &#125;, resources: &#123; en: &#123; translation: &#123; description: &#123; part1: &#x27;Edit &lt;1&gt;src/App.js&lt;/1&gt; and save to reload.&#x27;, part2: &#x27;Learn React&#x27; &#125;, counter: &#x27;Changed language just once&#x27;, counter_plural: &#x27;Changed language already &#123;&#123;count&#125;&#125; times&#x27; &#125; &#125;, de: &#123; translation: &#123; description: &#123; part1: &#x27;√Ñndere &lt;1&gt;src/App.js&lt;/1&gt; und speichere um neu zu laden.&#x27;, part2: &#x27;Lerne React&#x27; &#125;, counter: &#x27;Die Sprache wurde erst ein mal gewechselt&#x27;, counter_plural: &#x27;Die Sprache wurde &#123;&#123;count&#125;&#125; mal gewechselt&#x27; &#125; &#125; &#125; &#125;);export default i18n; Based on the count value i18next will choose the correct plural form. Read more about pluralization and interpolation in the official i18next documentation. üí° i18next is also able to handle languages with multiple plural forms, like arabic: 1234567891011121314151617181920// translation resources:&#123; &quot;key_0&quot;: &quot;zero&quot;, &quot;key_1&quot;: &quot;singular&quot;, &quot;key_2&quot;: &quot;two&quot;, &quot;key_3&quot;: &quot;few&quot;, &quot;key_4&quot;: &quot;many&quot;, &quot;key_5&quot;: &quot;other&quot;&#125;// usage:t(&#x27;key&#x27;, &#123;count: 0&#125;); // -&gt; &quot;zero&quot;t(&#x27;key&#x27;, &#123;count: 1&#125;); // -&gt; &quot;singular&quot;t(&#x27;key&#x27;, &#123;count: 2&#125;); // -&gt; &quot;two&quot;t(&#x27;key&#x27;, &#123;count: 3&#125;); // -&gt; &quot;few&quot;t(&#x27;key&#x27;, &#123;count: 4&#125;); // -&gt; &quot;few&quot;t(&#x27;key&#x27;, &#123;count: 5&#125;); // -&gt; &quot;few&quot;t(&#x27;key&#x27;, &#123;count: 11&#125;); // -&gt; &quot;many&quot;t(&#x27;key&#x27;, &#123;count: 99&#125;); // -&gt; &quot;many&quot;t(&#x27;key&#x27;, &#123;count: 100&#125;); // -&gt; &quot;other&quot; FormattingNow, let‚Äôs check out how we can use different date formats with the help of i18next and Luxon to handle date and time. npm install luxon We like to have a footer displaying the current date: 123456789101112import &#x27;./Footer.css&#x27;;const Footer = (&#123; t &#125;) =&gt; ( &lt;div className=&quot;Footer&quot;&gt; &lt;div&gt;&#123;t(&#x27;footer.date&#x27;, &#123; date: new Date() &#125;)&#125;&lt;/div&gt; &lt;/div&gt;);export default Footer;// imported in our App.js and used like this// &lt;Footer t=&#123;t&#125; /&gt; import luxon and define a format function in the interpolation options of i18next, like documented in the documentation and add the new translation key: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import i18n from &#x27;i18next&#x27;;import &#123; initReactI18next &#125; from &#x27;react-i18next&#x27;;import LanguageDetector from &#x27;i18next-browser-languagedetector&#x27;;import &#123; DateTime &#125; from &#x27;luxon&#x27;;i18n // detect user language // learn more: https://github.com/i18next/i18next-browser-languageDetector .use(LanguageDetector) // pass the i18n instance to react-i18next. .use(initReactI18next) // init i18next // for all options read: https://www.i18next.com/overview/configuration-options .init(&#123; debug: true, fallbackLng: &#x27;en&#x27;, interpolation: &#123; escapeValue: false, // not needed for react as it escapes by default format: (value, format, lng) =&gt; &#123; if (value instanceof Date) &#123; return DateTime.fromJSDate(value).setLocale(lng).toLocaleString(DateTime[format]) &#125; return value; &#125; &#125;, resources: &#123; en: &#123; translation: &#123; description: &#123; part1: &#x27;Edit &lt;1&gt;src/App.js&lt;/1&gt; and save to reload.&#x27;, part2: &#x27;Learn React&#x27; &#125;, counter: &#x27;Changed language just once&#x27;, counter_plural: &#x27;Changed language already &#123;&#123;count&#125;&#125; times&#x27;, footer: &#123; date: &#x27;Today is &#123;&#123;date, DATE_HUGE&#125;&#125;&#x27; &#125; &#125; &#125;, de: &#123; translation: &#123; description: &#123; part1: &#x27;√Ñndere &lt;1&gt;src/App.js&lt;/1&gt; und speichere um neu zu laden.&#x27;, part2: &#x27;Lerne React&#x27; &#125;, counter: &#x27;Die Sprache wurde erst ein mal gewechselt&#x27;, counter_plural: &#x27;Die Sprache wurde &#123;&#123;count&#125;&#125; mal gewechselt&#x27;, footer: &#123; date: &#x27;Heute ist &#123;&#123;date, DATE_HUGE&#125;&#125;&#x27; &#125; &#125; &#125; &#125; &#125;);export default i18n; üòé Cool, now we have a language specific date formatting! English: German: ContextWhat about a specific greeting message based on the current day time? i.e. morning, evening, etc. This is possible thanks to the context feature of i18next. Let&#39;s create a getGreetingTime function and use the result as context information for our footer translation: 1234567891011121314151617181920212223import &#123; DateTime &#125; from &#x27;luxon&#x27;;import &#x27;./Footer.css&#x27;;const getGreetingTime = (d = DateTime.now()) =&gt; &#123; const split_afternoon = 12; // 24hr time to split the afternoon const split_evening = 17; // 24hr time to split the evening const currentHour = parseFloat(d.toFormat(&#x27;hh&#x27;)); if (currentHour &gt;= split_afternoon &amp;&amp; currentHour &lt;= split_evening) &#123; return &#x27;afternoon&#x27;; &#125; else if (currentHour &gt;= split_evening) &#123; return &#x27;evening&#x27;; &#125; return &#x27;morning&#x27;;&#125;const Footer = (&#123; t &#125;) =&gt; ( &lt;div className=&quot;Footer&quot;&gt; &lt;div&gt;&#123;t(&#x27;footer.date&#x27;, &#123; date: new Date(), context: getGreetingTime() &#125;)&#125;&lt;/div&gt; &lt;/div&gt;);export default Footer; And add some context specific translations keys: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import i18n from &#x27;i18next&#x27;;import &#123; initReactI18next &#125; from &#x27;react-i18next&#x27;;import LanguageDetector from &#x27;i18next-browser-languagedetector&#x27;;import Backend from &#x27;i18next-http-backend&#x27;;import &#123; DateTime &#125; from &#x27;luxon&#x27;;i18n // i18next-http-backend // loads translations from your server // https://github.com/i18next/i18next-http-backend .use(Backend) // detect user language // learn more: https://github.com/i18next/i18next-browser-languageDetector .use(LanguageDetector) // pass the i18n instance to react-i18next. .use(initReactI18next) // init i18next // for all options read: https://www.i18next.com/overview/configuration-options .init(&#123; debug: true, fallbackLng: &#x27;en&#x27;, interpolation: &#123; escapeValue: false, // not needed for react as it escapes by default format: (value, format, lng) =&gt; &#123; if (value instanceof Date) &#123; return DateTime.fromJSDate(value).setLocale(lng).toLocaleString(DateTime[format]) &#125; return value; &#125; &#125;, resources: &#123; en: &#123; translation: &#123; description: &#123; part1: &#x27;Edit &lt;1&gt;src/App.js&lt;/1&gt; and save to reload.&#x27;, part2: &#x27;Learn React&#x27; &#125;, counter: &#x27;Changed language just once&#x27;, counter_plural: &#x27;Changed language already &#123;&#123;count&#125;&#125; times&#x27;, footer: &#123; date: &#x27;Today is &#123;&#123;date, DATE_HUGE&#125;&#125;&#x27;, date_morning: &#x27;Good morning! Today is &#123;&#123;date, DATE_HUGE&#125;&#125; | Have a nice day!&#x27;, date_afternoon: &#x27;Good afternoon! It\\&#x27;s &#123;&#123;date, DATE_HUGE&#125;&#125;&#x27;, date_evening: &#x27;Good evening! Today was the &#123;&#123;date, DATE_HUGE&#125;&#125;&#x27; &#125; &#125; &#125;, de: &#123; translation: &#123; description: &#123; part1: &#x27;√Ñndere &lt;1&gt;src/App.js&lt;/1&gt; und speichere um neu zu laden.&#x27;, part2: &#x27;Lerne React&#x27; &#125;, counter: &#x27;Die Sprache wurde erst ein mal gewechselt&#x27;, counter_plural: &#x27;Die Sprache wurde &#123;&#123;count&#125;&#125; mal gewechselt&#x27;, footer: &#123; date: &#x27;Heute ist &#123;&#123;date, DATE_HUGE&#125;&#125;&#x27;, date_morning: &#x27;Guten Morgen! Heute ist &#123;&#123;date, DATE_HUGE&#125;&#125; | W√ºnsche einen sch√∂nen Tag!&#x27;, date_afternoon: &#x27;Guten Tag! Es ist &#123;&#123;date, DATE_HUGE&#125;&#125;&#x27;, date_evening: &#x27;Guten Abend! Heute war &#123;&#123;date, DATE_HUGE&#125;&#125;&#x27; &#125; &#125; &#125; &#125; &#125;);export default i18n; üòÅ Yeah, It works! Separate translations from codeHaving the translations in our i18n.js file works, but is not that suitable to work with, for translators. Let&#39;s separate the translations from the code and pleace them in dedicated json files. Because this is a web application, i18next-http-backend will help us to do so. npm install i18next-http-backend Move the translations to the public folder: Adapt the i18n.js file to use the i18next-http-backend: 123456789101112131415161718192021222324252627282930313233import i18n from &#x27;i18next&#x27;;import &#123; initReactI18next &#125; from &#x27;react-i18next&#x27;;import LanguageDetector from &#x27;i18next-browser-languagedetector&#x27;;import Backend from &#x27;i18next-http-backend&#x27;;import &#123; DateTime &#125; from &#x27;luxon&#x27;;i18n // i18next-http-backend // loads translations from your server // https://github.com/i18next/i18next-http-backend .use(Backend) // detect user language // learn more: https://github.com/i18next/i18next-browser-languageDetector .use(LanguageDetector) // pass the i18n instance to react-i18next. .use(initReactI18next) // init i18next // for all options read: https://www.i18next.com/overview/configuration-options .init(&#123; debug: true, fallbackLng: &#x27;en&#x27;, interpolation: &#123; escapeValue: false, // not needed for react as it escapes by default format: (value, format, lng) =&gt; &#123; if (value instanceof Date) &#123; return DateTime.fromJSDate(value).setLocale(lng).toLocaleString(DateTime[format]) &#125; return value; &#125; &#125; &#125;);export default i18n; Now the translations are loaded asynchronously, so make sure you wrap your app with a Suspense component to prevent this error: Uncaught Error: App suspended while rendering, but no fallback UI was specified. 1234567891011121314import &#123; Suspense &#125; from &#x27;react&#x27;;function App() &#123; // your app&#x27;s code...&#125;// here app catches the suspense from page in case translations are not yet loadedexport default function WrappedApp() &#123; return ( &lt;Suspense fallback=&quot;...is loading&quot;&gt; &lt;App /&gt; &lt;/Suspense&gt; );&#125; Now your app looks still the same, but your translations are separated. If you want to support a new language, you just create a new folder and a new translation json file. This gives you the possibility to send the translations to some translators. Or if you&#39;re working with a translation management system you can just synchronize the files with a cli. üí° btw: you can also have multiple translation files thanks to the namespaces feature of i18next üßë‚Äçüíª The code of this first part can be found here. Better translation managementBy sending the translations to some translators or translator agency you have more control and a direct contact with them. But this also means more work for you. This is a traditional way. But be aware sending files around creates always an overhead. Does a better option exist? For sure!i18next helps to get the application translated, and this is great - but there is more to it. How do you integrate any translation services / agency? How do you keep track of new or removed content? How you handle proper versioning? How you deploy translation changes without deploying your complete application? and a lot more... Looking for something like this‚ùì Easy to integrate Continuous deployment? Continuous localization! Manage the translation files with ease Order professional translations Analytics &amp; Statistics Profit from our content delivery network (CDN) Versioning of your translations Automatic and On-Demand Machine Translation Riskfree: Take your data with you Transparent and fair pricing and a lot more... How does this look like?First you need to signup at locize and login. Then create a new project in locize and add your translations. You can add your translations either by using the cli or by importing the individual json files or via API. Done so, we&#39;re going to replace i18next-http-backend with i18next-locize-backend. npm install i18next-locize-backend After having imported the translations to locize, delete the locales folder: Adapt the i18n.js file to use the i18next-locize-backend and make sure you copy the project-id and api-key from within your locize project: 12345678910111213141516171819202122232425262728293031323334353637383940import i18n from &#x27;i18next&#x27;;import &#123; initReactI18next &#125; from &#x27;react-i18next&#x27;;import LanguageDetector from &#x27;i18next-browser-languagedetector&#x27;;import Backend from &#x27;i18next-locize-backend&#x27;;import &#123; DateTime &#125; from &#x27;luxon&#x27;;const locizeOptions = &#123; projectId: &#x27;0bbc223a-9aba-4a90-ab93-ab9d7bf7f780&#x27;, apiKey: &#x27;aaad4141-54ba-4625-ae37-657538fe29e7&#x27;, // YOU should not expose your apps API key to production!!! referenceLng: &#x27;en&#x27;,&#125;;i18n // i18next-locize-backend // loads translations from your project, saves new keys to it (saveMissing: true) // https://github.com/locize/i18next-locize-backend .use(Backend) // detect user language // learn more: https://github.com/i18next/i18next-browser-languageDetector .use(LanguageDetector) // pass the i18n instance to react-i18next. .use(initReactI18next) // init i18next // for all options read: https://www.i18next.com/overview/configuration-options .init(&#123; debug: true, fallbackLng: &#x27;en&#x27;, interpolation: &#123; escapeValue: false, // not needed for react as it escapes by default format: (value, format, lng) =&gt; &#123; if (value instanceof Date) &#123; return DateTime.fromJSDate(value).setLocale(lng).toLocaleString(DateTime[format]) &#125; return value; &#125; &#125;, backend: locizeOptions &#125;);export default i18n; i18next-locize-backend offers a functionality to retrieve the available languages directly from locize, let&#39;s use it: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import logo from &#x27;./logo.svg&#x27;;import &#x27;./App.css&#x27;;import &#123; useTranslation, Trans &#125; from &#x27;react-i18next&#x27;;import &#123; useState, Suspense, useEffect &#125; from &#x27;react&#x27;;import Footer from &#x27;./Footer&#x27;function App() &#123; const &#123; t, i18n &#125; = useTranslation(); const [count, setCounter] = useState(0); const [lngs, setLngs] = useState(&#123; en: &#123; nativeName: &#x27;English&#x27; &#125;&#125;); useEffect(() =&gt; &#123; i18n.services.backendConnector.backend.getLanguages((err, ret) =&gt; &#123; if (err) return // TODO: handle err... setLngs(ret); &#125;); &#125;, []); return ( &lt;div className=&quot;App&quot;&gt; &lt;header className=&quot;App-header&quot;&gt; &lt;img src=&#123;logo&#125; className=&quot;App-logo&quot; alt=&quot;logo&quot; /&gt; &lt;div&gt; &#123;Object.keys(lngs).map((lng) =&gt; ( &lt;button key=&#123;lng&#125; style=&#123;&#123; fontWeight: i18n.language === lng ? &#x27;bold&#x27; : &#x27;normal&#x27; &#125;&#125; type=&quot;submit&quot; onClick=&#123;() =&gt; &#123; i18n.changeLanguage(lng); setCounter(count + 1); &#125;&#125;&gt; &#123;lngs[lng].nativeName&#125; &lt;/button&gt; ))&#125; &lt;/div&gt; &lt;p&gt; &lt;i&gt;&#123;t(&#x27;counter&#x27;, &#123; count &#125;)&#125;&lt;/i&gt; &lt;/p&gt; &lt;p&gt; &lt;Trans i18nKey=&quot;description.part1&quot;&gt; Edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload. &lt;/Trans&gt; &lt;/p&gt; &lt;a className=&quot;App-link&quot; href=&quot;https://reactjs.org&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; &gt; &#123;t(&#x27;description.part2&#x27;)&#125; &lt;/a&gt; &lt;/header&gt; &lt;Footer t=&#123;t&#125; /&gt; &lt;/div&gt; );&#125;// here app catches the suspense from page in case translations are not yet loadedexport default function WrappedApp() &#123; return ( &lt;Suspense fallback=&quot;...is loading&quot;&gt; &lt;App /&gt; &lt;/Suspense&gt; );&#125; save missing translationsThanks to the use of the saveMissing functionality, new keys gets added to locize automatically, while developing the app. Just pass saveMissing: true in the i18next options: 1234567891011121314151617181920212223242526272829303132333435363738394041import i18n from &#x27;i18next&#x27;;import &#123; initReactI18next &#125; from &#x27;react-i18next&#x27;;import LanguageDetector from &#x27;i18next-browser-languagedetector&#x27;;import Backend from &#x27;i18next-locize-backend&#x27;;import &#123; DateTime &#125; from &#x27;luxon&#x27;;const locizeOptions = &#123; projectId: &#x27;0bbc223a-9aba-4a90-ab93-ab9d7bf7f780&#x27;, apiKey: &#x27;aaad4141-54ba-4625-ae37-657538fe29e7&#x27;, // YOU should not expose your apps API key to production!!! referenceLng: &#x27;en&#x27;,&#125;;i18n // i18next-locize-backend // loads translations from your project, saves new keys to it (saveMissing: true) // https://github.com/locize/i18next-locize-backend .use(Backend) // detect user language // learn more: https://github.com/i18next/i18next-browser-languageDetector .use(LanguageDetector) // pass the i18n instance to react-i18next. .use(initReactI18next) // init i18next // for all options read: https://www.i18next.com/overview/configuration-options .init(&#123; debug: true, fallbackLng: &#x27;en&#x27;, interpolation: &#123; escapeValue: false, // not needed for react as it escapes by default format: (value, format, lng) =&gt; &#123; if (value instanceof Date) &#123; return DateTime.fromJSDate(value).setLocale(lng).toLocaleString(DateTime[format]) &#125; return value; &#125; &#125;, backend: locizeOptions, saveMissing: true &#125;);export default i18n; Each time you&#39;ll use a new key, it will be sent to locize, i.e.: 1&lt;div&gt;&#123;t(&#x27;new.key&#x27;, &#x27;this will be added automatically&#x27;)&#125;&lt;/div&gt; will result in locize like this: üëÄ but there&#39;s more...Thanks to the locize-lastused plugin, you&#39;ll be able to find and filter in locize which keys are used or not used anymore. With the help of the locize plugin, you&#39;ll be able to use your app within the locize InContext Editor. Lastly, with the help of the auto-machinetranslation workflow and the use of the saveMissing functionality, new keys not only gets added to locize automatically, while developing the app, but are also automatically translated into the target languages using machine translation. Check out this video to see how the automatic machine translation workflow looks like! npm install locize-lastused locize use them in i18n.js: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import i18n from &#x27;i18next&#x27;;import &#123; initReactI18next &#125; from &#x27;react-i18next&#x27;;import LanguageDetector from &#x27;i18next-browser-languagedetector&#x27;;import Backend from &#x27;i18next-locize-backend&#x27;;import LastUsed from &#x27;locize-lastused&#x27;;import &#123; locizePlugin &#125; from &#x27;locize&#x27;;import &#123; DateTime &#125; from &#x27;luxon&#x27;;const locizeOptions = &#123; projectId: &#x27;0bbc223a-9aba-4a90-ab93-ab9d7bf7f780&#x27;, apiKey: &#x27;aaad4141-54ba-4625-ae37-657538fe29e7&#x27;, // YOU should not expose your apps API key to production!!! referenceLng: &#x27;en&#x27;,&#125;;i18n // locize-lastused // sets a timestamp of last access on every translation segment on locize // -&gt; safely remove the ones not being touched for weeks/months // https://github.com/locize/locize-lastused .use(LastUsed) // locize-editor // InContext Editor of locize .use(locizePlugin) // i18next-locize-backend // loads translations from your project, saves new keys to it (saveMissing: true) // https://github.com/locize/i18next-locize-backend .use(Backend) // detect user language // learn more: https://github.com/i18next/i18next-browser-languageDetector .use(LanguageDetector) // pass the i18n instance to react-i18next. .use(initReactI18next) // init i18next // for all options read: https://www.i18next.com/overview/configuration-options .init(&#123; debug: true, fallbackLng: &#x27;en&#x27;, interpolation: &#123; escapeValue: false, // not needed for react as it escapes by default format: (value, format, lng) =&gt; &#123; if (value instanceof Date) &#123; return DateTime.fromJSDate(value).setLocale(lng).toLocaleString(DateTime[format]) &#125; return value; &#125; &#125;, backend: locizeOptions, locizeLastUsed: locizeOptions, saveMissing: true &#125;);export default i18n; Automatic machine translation: Last used translations filter: InContext Editor: üì¶ Let&#39;s prepare for production üöÄNow, we prepare the app for going to production. First in locize, create a dedicated version for production. Do not enable auto publish for that version but publish manually or via API or via CLI. Lastly, enable Cache-Control max-age‚Äã for that production version. Let&#39;s making use of the environment feature of react-scripts. Lets&#39; create a default environment file and one for development and one for production: .env: 1234567SKIP_PREFLIGHT_CHECK&#x3D;trueREACT_APP_VERSION&#x3D;$npm_package_version# locizeREACT_APP_LOCIZE_PROJECTID&#x3D;0bbc223a-9aba-4a90-ab93-ab9d7bf7f780REACT_APP_LOCIZE_REFLNG&#x3D;en .env.development: 12REACT_APP_LOCIZE_VERSION&#x3D;latestREACT_APP_LOCIZE_APIKEY&#x3D;aaad4141-54ba-4625-ae37-657538fe29e7 .env.production: 1REACT_APP_LOCIZE_VERSION&#x3D;production Now let&#39;s adapt the i18n.js file: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import i18n from &#x27;i18next&#x27;;import &#123; initReactI18next &#125; from &#x27;react-i18next&#x27;;import LanguageDetector from &#x27;i18next-browser-languagedetector&#x27;;import Backend from &#x27;i18next-locize-backend&#x27;;import LastUsed from &#x27;locize-lastused&#x27;;import &#123; locizePlugin &#125; from &#x27;locize&#x27;;import &#123; DateTime &#125; from &#x27;luxon&#x27;;const isProduction = process.env.NODE_ENV === &#x27;production&#x27;;const locizeOptions = &#123; projectId: process.env.REACT_APP_LOCIZE_PROJECTID, apiKey: process.env.REACT_APP_LOCIZE_APIKEY, // YOU should not expose your apps API key to production!!! referenceLng: process.env.REACT_APP_LOCIZE_REFLNG, version: process.env.REACT_APP_LOCIZE_VERSION&#125;;if (!isProduction) &#123; // locize-lastused // sets a timestamp of last access on every translation segment on locize // -&gt; safely remove the ones not being touched for weeks/months // https://github.com/locize/locize-lastused i18n.use(LastUsed);&#125;i18n // locize-editor // InContext Editor of locize .use(locizePlugin) // i18next-locize-backend // loads translations from your project, saves new keys to it (saveMissing: true) // https://github.com/locize/i18next-locize-backend .use(Backend) // detect user language // learn more: https://github.com/i18next/i18next-browser-languageDetector .use(LanguageDetector) // pass the i18n instance to react-i18next. .use(initReactI18next) // init i18next // for all options read: https://www.i18next.com/overview/configuration-options .init(&#123; debug: true, fallbackLng: &#x27;en&#x27;, interpolation: &#123; escapeValue: false, // not needed for react as it escapes by default format: (value, format, lng) =&gt; &#123; if (value instanceof Date) &#123; return DateTime.fromJSDate(value).setLocale(lng).toLocaleString(DateTime[format]) &#125; return value; &#125; &#125;, backend: locizeOptions, locizeLastUsed: locizeOptions, saveMissing: !isProduction // you should not use saveMissing in production &#125;);export default i18n; Now, during development, you&#39;ll continue to save missing keys and to make use of lastused feature. =&gt; npm run start And in production environment, saveMissing and lastused are disabled, and also the api-key is not exposed. =&gt; npm run build &amp;&amp; npm run serve Caching: Merging versions: üßë‚Äçüíª The complete code can be found here. üéâü•≥ Congratulations üéäüéÅI hope you‚Äôve learned a few new things about i18next, React.js localization and modern localization workflows. So if you want to take your i18n topic to the next level, it&#39;s worth to try locize. The founders of locize are also the creators of i18next. So with using locize you directly support the future of i18next. üëç","categories":[{"name":"Post","slug":"Post","permalink":"http://blog.locize.com/categories/Post/"}],"tags":[{"name":"locize","slug":"locize","permalink":"http://blog.locize.com/tags/locize/"},{"name":"localization","slug":"localization","permalink":"http://blog.locize.com/tags/localization/"},{"name":"internationalization","slug":"internationalization","permalink":"http://blog.locize.com/tags/internationalization/"},{"name":"i18next","slug":"i18next","permalink":"http://blog.locize.com/tags/i18next/"},{"name":"translation","slug":"translation","permalink":"http://blog.locize.com/tags/translation/"}]},{"title":"What's new in locize","slug":"2020-12-02-new-locize","date":"2020-12-01T23:00:00.000Z","updated":"2021-04-12T08:36:26.470Z","comments":true,"path":"2020-12-02-new-locize/","link":"","permalink":"http://blog.locize.com/2020-12-02-new-locize/","excerpt":"","text":"A lot of work may be virtual now, but that doesn‚Äôt mean we‚Äôve slowed down! In fact, we spent the last months working on a new locize version with a bunch of fabulous updates. Here&#39;s a run-down of some of the most important tweaks that make a huge difference. Modernized UIFirst of all, you will notice locize looks different. The layout is a little less angular and a little more rounded. There are more icons and more charts. This makes it look friendlier, simpler, and tidier. The layout is composed by different cards. Each card has optional additional functionality in the top right corder. Different partsThe application was rewritten from the ground up and now splits into two major parts. Project pagesThe project pages consists of details and actions about your versions, languages, namespaces, etc. There&#39;s also an optional card about your orders and another card about your branched projects (crowdbased and localistars) We moved everything related to the development to a dedicated page, containing development settings, api keys and relevant metrics. There&#39;s also the possibility to configure a webhook or integrate slack. CAT pagesThe other major part is the new computer aided translation tool ‚Äì short CAT. The new CAT tool comes with three separate views, for: Global overviewWith global imports and exports, add, copy or delete keys, search and filter. TranslationFocus on translating, assisted by machine translation (MT), smart translation memory (TM), consistency checks, and more. InContext editingThe InContext Editor just needs a little script (locize or locizify) added to your site, so it can exchange information (clicked text, saved changes, etc.). Find more information in the documentationNew featuresThe new locize app does not only come with a new fresh look ‚Äì but also brings you a ton of new awesome features, like the review workflow or the key history. ReviewYou can enable the review workflow for specific languages. This way each time someone changes a translation, it will start a review workflow. The actual value will not be changed until someone will accept one of the translation proposals. HistoryThe last translation changes are audited per key. SummaryTo make it short ‚Äì every aspect of the old experience was analyzed and improved to give you an even better experience. The only thing we did not change was the price. You get all the new features without any increase of costs. If you got any questions, feedback or suggestions ‚Äì we would love to hear from you at support@locize.com.","categories":[{"name":"Post","slug":"Post","permalink":"http://blog.locize.com/categories/Post/"}],"tags":[{"name":"locize","slug":"locize","permalink":"http://blog.locize.com/tags/locize/"},{"name":"localization","slug":"localization","permalink":"http://blog.locize.com/tags/localization/"},{"name":"internationalization","slug":"internationalization","permalink":"http://blog.locize.com/tags/internationalization/"},{"name":"translation","slug":"translation","permalink":"http://blog.locize.com/tags/translation/"}]},{"title":"Stay ahead of the game with localistars","slug":"2020-06-13-localistars","date":"2020-06-12T22:00:00.000Z","updated":"2021-04-12T08:36:21.737Z","comments":true,"path":"2020-06-13-localistars/","link":"","permalink":"http://blog.locize.com/2020-06-13-localistars/","excerpt":"","text":"While you can let your translation done by freelancers or inhouse employees using locize itself you also got the options to directly order translations from inside locize. With the existing integrations we weren&#39;t that happy. That&#39;s one of the reasons why we decided to integrate a complete new marketplace platform, which works in a more fair way. Welcome localistars!localistars is the go-to marketplace for clients and translators to get translation jobs done. As client you&#39;ll find translators and as translator you&#39;ll find translation jobs. Direct contact, no middleman ‚Äì just collaborating! How is localistars different?As we know how hard it can be to have a solid and working localization process between developers and technical editors / translators, our mission is to offer a platform where everybody is efficient to do its own work and everybody is happy. localistars is completely in line with locize&#39;s mission: &quot;Bridging the gap between translation and development&quot; With localistars you&#39;re in direct contact with the translator ‚Äì it&#39;s your project, you hold the reins. In contrast to other services localistars don&#39;t set the price and forward the contract to the cheapest translator to maximize the profit. You choose the translator for your projects yourself, it&#39;s your contractor. Find the best offerChoose the best fitting translators. As client you accept bids based on price and experience of the translator. Direct contactThere is no middleman ‚Äì you get direct access to the experts. No annoying text monitoring or filtering. As client you may choose to collaborate with the same translators for future projects and grow your own team. Translators are in the actorsIf you are a translator or copywriter (freelancer or agency) who enjoys working autonomously, then localistars is the perfect platform for you - localistars is about you. Find new clients with ease. More time to do the meaningful work, less time wasted on searching and contracting. Overall localistars is your chance to increase your income. Content-centricIt&#39;s all about the content. Projects are set-up with content in mind so the localistars can work together effectively. Clients want to reach their global audience while translators want to choose from diverse tasks. We heard you both. Risk-free paymentClients will only be charged if they approve the content provided by a translator. As a localistar you don&#39;t need to worry about your payment. Translators always get paid on approval. Getting started with localistarsGetting started is simple ‚Äì the first step is to signup or signin on localistars. Set up your profile and your organisation. Then follow this guide. Check out the video and be a localistar!","categories":[{"name":"Post","slug":"Post","permalink":"http://blog.locize.com/categories/Post/"}],"tags":[{"name":"service","slug":"service","permalink":"http://blog.locize.com/tags/service/"},{"name":"locize","slug":"locize","permalink":"http://blog.locize.com/tags/locize/"},{"name":"localization","slug":"localization","permalink":"http://blog.locize.com/tags/localization/"},{"name":"internationalization","slug":"internationalization","permalink":"http://blog.locize.com/tags/internationalization/"},{"name":"translation","slug":"translation","permalink":"http://blog.locize.com/tags/translation/"},{"name":"localistars","slug":"localistars","permalink":"http://blog.locize.com/tags/localistars/"},{"name":"order","slug":"order","permalink":"http://blog.locize.com/tags/order/"}]},{"title":"A tale of the last 10 years in web development","slug":"2018-08-28-a-tale-of-the-last-10-years-in-web-development","date":"2018-08-27T22:00:00.000Z","updated":"2018-08-28T07:18:33.000Z","comments":true,"path":"2018-08-28-a-tale-of-the-last-10-years-in-web-development/","link":"","permalink":"http://blog.locize.com/2018-08-28-a-tale-of-the-last-10-years-in-web-development/","excerpt":"","text":"![](title.png \"locize ¬© inweso GmbH\") This is a work of fiction. Names, characters, businesses, places, events, locales, and incidents depicted in this story are either the products of my imagination or used in a fictitious manner. Any resemblance to actual persons, living or dead, or actual events is purely coincidental. An IntroductionThis story is based on a true story of each of us. Over the past 10 years, many web developers have experienced such a journey. Starting from jQuery, passing through Angular, using React and streak Vue. When reading, ‚Äúdarker areas‚Äù of the beginnings of single page applications (SPA) are undergone. This can cause unwanted nervous muscle twitches from the past. For risks and side effects read the package leaflet (there is none) and consult your doctor or pharmacist (I don‚Äôt know if they could understand). Once upon a time, in spring 2008 in a small company in Sheffield, there was a software developer called Dorian. He was working on a desktop application built with Microsoft .NET.Not far from there, in Rotherham, Shaun worked in a similar company as web developer.Both companies were very similar and sometimes even had the same customers. So it happened that the top management of both companies met and they merged.Patty, who had been promoted to development manager, had the task to assemble a new web development team. After she had already inducted Shaun into her team, she also found Dorian and noticed a possible team change.She beat him an offer and Dorian joined straight the team in Rotherham.For Dorian, professional development with Javascript was something new. He‚Äôd learned Javascript during his studies, but he‚Äôd used it rather than animate a website.Shaun, on the other hand, even showed him how to handle node.js and linux and mac. Dorian had always only worked with Windows so far. And from Javascript in the backend he was quite astonished and surprised.Patty saw the first weeks relaxed and felt that she was uniting these two, the right thing. Soon it was time to productively implement a new web application. Together, they decided to try to use node.js in the backend and jQuery in the frontend.They did choose jQuery because the support of the community was great, it made DOM manipulation painless, played well with AJAX, made basic animation a piece of cake, had a lot of plug-ins, etc‚Ä¶Since the web application was not only for English speaking users, they used jquery-i18next as an internationalization (i18n) library. To see how this could look like click here. After about 3 to 4 years, the first signs of weakness of the web application began.There were overusing big/clever plugins, had big/complex files and polluted the global namespace.The heavy use of long chains of selectors (‚Äúul#leftnav li p a.current‚Äú) made the code brittle.They started to lose track of what‚Äôs where because of the neat idea to use .data() to attach data to the DOM elements, to track the page state.Everything started being slow‚Ä¶Patty had new major features in the pipeline. But the team, which had problems to grow, recommended a refactoring phase.Quickly the team got support from 2 freelancers, Serge and Martina. Patty introduced the new ones as ‚Äúthe experts‚Äù.Serge and Martina had Angular know-how and persuaded everyone to replace the jQuery solution with Angular.Their arguments sounded promising:Instead of unobtrusive Javascript with selectors, now declarative templates.From semantic HTML, to semantic models. Instead of classic separation of concerns (HTML, CSS, JS), the usage of MVC pattern. No plug-ins but directives. $scope instead of closure.Instead of manual DOM manipulation and binding, modern data binding. Less ‚Äúspaghetti‚Äù code and more dependency injection. From unorganized, to modular service architecture. Because i18next was not only built for jQuery, they could use ng-i18next and at least keep the same configuration and use the same localization files as before! To see how this could look like click here. During the next 3 to 4 years, Patty added more freelancers and contractors to the team.Shaun and Dorian started to recognize that making the simplest features work seems a struggle.There were more and more performance and complexity issues.Directives, services and filters theoretically were available, but ultimately, everything was built around controllers and their two-way bound $scope.Angular seemed to be fine for the beginning, when it was a simple application, but as the frontend application grew in complexity, this led to the scope soup problem amongst other issues.Additionally, the fear of Angular 2‚Äôs release was on the horizon. By trying some samples, Shaun said: ‚ÄúIs this still Angular?‚Äù In the meantime, the backend had turned into a solid foundation based on DDD, CQRS and event sourcing.During a late-night beer, Dorian told Shaun about React and Redux. He said that when he read about React, Redux and FLUX he immediately felt that this was a natural fit to the existing backend.Finally, they convinced Patty to rewrite the whole frontend with these arguments: Angular was a framework vs. React was a library the more flexible state management with Redux virtual DOM, one-way data flow, PropTypes and a well-defined component lifecycle the obvious natural fit with their backend single source of truth JSX, a natural evolution of Javascript React has faster learning curve. It feels like learning faster. As with the last technology change, this time there was an i18next option. Just used the new react-i18next library and still the same localization files! To see how this could look like click here. Around the year 2018, many freelancers and contractors were no longer in the team. Instead of them now younger developers started to ask for something new‚Ä¶ ‚ÄúReact is ok, but what‚Äôs about Vue?‚Äù Shaun and Dorian organized a little technical session and they explained that React and Vue had more similarities than differences: both were fast and lightweight both had a component based architecture both used a virtual DOM both could be dropped into a single HTML file or be a module in a more sophisticated webpack setup both had separate router and state management libraries Long talk short, the session ended with the following sentence by Shaun: ‚ÄúOk, let‚Äôs try to write our web app in Vue and create a PoC‚Ä¶‚Äù Whether they‚Äôve really switched to Vue, we do not know, but what we know is that if that‚Äôs the case, then they‚Äôre sure to use vue-i18next or a similar library. To see how this could look like click here. i18next was right: ‚Äúlearn once ‚Äî translate everywhere‚Äù! Technologies and libraries come and go, but i18next remains! Post-credits sceneThere are voices who say that they have also replaced their i18next-xhr-backend with that of locize. To see how this could look like look at this video.","categories":[{"name":"Post","slug":"Post","permalink":"http://blog.locize.com/categories/Post/"}],"tags":[{"name":"locize","slug":"locize","permalink":"http://blog.locize.com/tags/locize/"},{"name":"localization","slug":"localization","permalink":"http://blog.locize.com/tags/localization/"},{"name":"internationalization","slug":"internationalization","permalink":"http://blog.locize.com/tags/internationalization/"},{"name":"i18next","slug":"i18next","permalink":"http://blog.locize.com/tags/i18next/"},{"name":"web","slug":"web","permalink":"http://blog.locize.com/tags/web/"}]},{"title":"locize - Translation Software Distinguished by Platform for SaaS Reviews as a Great User Experience and Rising Star for 2018","slug":"2018-04-30-locize-double-win-2018-for-translation-software","date":"2018-04-29T22:00:00.000Z","updated":"2019-03-07T13:51:18.000Z","comments":true,"path":"2018-04-30-locize-double-win-2018-for-translation-software/","link":"","permalink":"http://blog.locize.com/2018-04-30-locize-double-win-2018-for-translation-software/","excerpt":"","text":"Efficient localization need not to be expensive, disorganized, and time-consuming for development and localization teams. We designed locize with this core ideas in mind, and a popular software review platform has recently recognized our efforts and affirmed that we have succeeded in our endeavor. FinancesOnline recently distinguished locize with the Great User Experience and Rising Star awards for 2018 due to our localization and internationalization software‚Äôs capability to satisfy the large demands of global businesses. locize earned FinancesOnline‚Äôs Great User Experience award under their best translation software for our offering an incredibly pleasing to use software for continuously localizing all kinds of languages and software. Project versioning for easy tracking of file changes, multiple file management and project progress tracking through the dashboard, and third-party integrations are some of the factors that contributed to this award. Their experts also praised our platform‚Äôs flexibility and responsiveness reflecting all translations on one‚Äôs website by simply embedding a single line of code, a feature that makes locize among the best translation software competitors. This also negates the need for manual inputting of all translations. The FinancesOnline review team also regarded locize as a Rising Star for 2018 due to our highly positive traction with clients. It isn‚Äôt a surprise to see our software receive this distinction after FinancesOnline wrote positive remarks in their locize review such as ‚Äúcost-effective‚Äù, ‚Äúalways safe‚Äù content thanks to our two-factor authentication, and accelerated and streamlined localization processes.","categories":[{"name":"Post","slug":"Post","permalink":"http://blog.locize.com/categories/Post/"}],"tags":[{"name":"locize","slug":"locize","permalink":"http://blog.locize.com/tags/locize/"},{"name":"continuous localization","slug":"continuous-localization","permalink":"http://blog.locize.com/tags/continuous-localization/"},{"name":"award","slug":"award","permalink":"http://blog.locize.com/tags/award/"}]},{"title":"Is your software ready for localization?","slug":"2018-02-23-is-your-software-ready-for-localization","date":"2018-02-22T23:00:00.000Z","updated":"2018-08-28T07:03:39.000Z","comments":true,"path":"2018-02-23-is-your-software-ready-for-localization/","link":"","permalink":"http://blog.locize.com/2018-02-23-is-your-software-ready-for-localization/","excerpt":"","text":"![](title.png \"locize ¬© inweso GmbH\") So you want people from all around the world to use and understand your software... ...but how to achieve that? Which format should I use?Think about the workflow of exporting strings of the software, having them translated and then importing them back into your software. This will give you many ideas on how to structure your strings. Sometimes the used library already pretends a format. For web projects for example this can be: JSON (i.e. used by i18next) ICU Message syntax (i.e. used by formatjs) ... For mobile projects for example this can be: Localizable.strings (i.e. used by iOS) XML String Resource (i.e. used by Android) ... For system apps for example this can be: Java properties files (i.e. used by Java) ResX files (i.e. used by .Net) ... Do you hardcode text strings in the source code?Resource files should store all text used in the software; do not leave text strings hardcoded! Just don&#39;t! Can the order of variables in localized strings be changed?Implement a token system to ensure nouns, verbs, etc. can be placed in unique order by language. Different languages needs to know more information about the context. For example for pluralization or gender. The Italian language for example relies on gender. The words in the sentence change depending on whether you&#39;re talking about a man or a woman. Polish suppose you have a singular and then you have a different plural depending on whether the number of things ends with 2, 3 and 4 or some other digit. And Romanian need a different plural for any group of objects greater than 20. Does the interface allow for long translations?What about long translations in areas with single line text? Are there areas with multi-line text in your software? Sentences that take five syllables in English actually take a whole two paragraph description in some other language. Do you use unique string IDs?Unique string IDs help keep development, translation and QA teams on the same page. Another reason for this is: if you have for example a text in English that is visible in 2 different places on your UI, but is potentially translated differently in other languages (because it fits better). What about fonts? Who selects their types and sizes in the software?Both localization and development teams should select fonts as a cooperative effort. And how do you decide on the proportion of fonts? While fonts for North American and European languages should be &quot;Proportional&quot;, &quot;Monospace&quot; is the right type for Asian languages. Are the fonts compatible with special characters for all languages? Different languages, different needs: for special characters, word order, even numbers. How are date, time, currency, and numbers displayed?Allow date, time, currency, and numbers to be displayed with differing figures and number separators by language or even region. Make sure the date format is right because Americans do month/day/year Brit day/month/year and by the way in America the week starts on a Sunday and in Britain the week starts on Monday. Europe wants 24 hour clocks and America wants 12 hour clocks. Regarding numbers, here a little list: source What encoding do you use for your text assets?Choose an encoding that supports all target languages. If you don&#39;t know, just choose UTF-8. If you want to know Why UTF-8 is the best encoding? read this article. By the way, to tell apart assets intended for a particular locale use ISO 693-1 &amp; 3166-1 language and country codes to mark assets by locale. Do the art assets of your software UI have text?Be ready to swap art assets if they contain legible text. Sometimes even if there is no legible text you may want to adapt the art asset (i.e. an image) because of cultural reasons. There are some libraries that can help with this issue i.e. Fragment replacement for links and images Did you put the original text through a spelling, grammar, and style check?Prevent back-and-forth rechecking that my stall the whole process. As an alternative you should be thinking of making some sort of Continuous Localization. With Continuous Localization you can take care of the translations from the first day and keep up with changes with ease. The process of translation and development are separated. Do you use a tracking system?Tracking every change on localizable content can be important to ensure that no content will be left behind when distributing your software. For certain projects or industries it&#39;s important to know which translator has done what change for auditing reasons. Some translation management systems offer a dedicated audit feature. This empowers you to prove anytime when a content fragment was changed. What file formats are you sending for translation work?JSON, XML (or a derivative format i.e. XLIFF) is preferred over plain text or Excel files. Even better are localization management systems that offers a completely integrated approach. Where are the localization assets?Store localization assets in an easy to access location, for swift access, import and export. With a proper Continuous Localization solution translations can be updated without the need to release an update of your app. For example: translations deployed to a CDN and consumed from your application. Do you intend to have the texts translated into more than one language?Process resource files into separate language ones so all translators can work in parallel. A good localization management solution can really help here. All team members can collaboratively work in parallel. In this way, you can get to your objective in a faster way. How do you track which language is fully translated?To say it in one sentence: &quot;Start thinking about the localization process early!&quot; The biggest mistake one can do is looking on localization as it‚Äôs only based on instrumenting your code and extract texts into resource files so you can translate them later. You should keep full overview about what is translated and what not ‚Äî even more if you order translations from the translation providers you also should keep track of your open orders.","categories":[{"name":"Post","slug":"Post","permalink":"http://blog.locize.com/categories/Post/"}],"tags":[{"name":"locize","slug":"locize","permalink":"http://blog.locize.com/tags/locize/"},{"name":"localization","slug":"localization","permalink":"http://blog.locize.com/tags/localization/"},{"name":"internationalization","slug":"internationalization","permalink":"http://blog.locize.com/tags/internationalization/"},{"name":"i18next","slug":"i18next","permalink":"http://blog.locize.com/tags/i18next/"},{"name":"formatjs","slug":"formatjs","permalink":"http://blog.locize.com/tags/formatjs/"},{"name":"continuous development","slug":"continuous-development","permalink":"http://blog.locize.com/tags/continuous-development/"},{"name":"continuous integration","slug":"continuous-integration","permalink":"http://blog.locize.com/tags/continuous-integration/"},{"name":"continuous localization","slug":"continuous-localization","permalink":"http://blog.locize.com/tags/continuous-localization/"},{"name":"continuous delivery","slug":"continuous-delivery","permalink":"http://blog.locize.com/tags/continuous-delivery/"},{"name":"continuous translation","slug":"continuous-translation","permalink":"http://blog.locize.com/tags/continuous-translation/"}]},{"title":"8 signs you should improve your localization process","slug":"2017-08-15-8-signs-you-should-improve-your-localization-process","date":"2017-08-14T22:00:00.000Z","updated":"2017-08-15T09:59:58.000Z","comments":true,"path":"2017-08-15-8-signs-you-should-improve-your-localization-process/","link":"","permalink":"http://blog.locize.com/2017-08-15-8-signs-you-should-improve-your-localization-process/","excerpt":"","text":"![](title.png \"locize ¬© inweso GmbH\") Very often, when you&#39;re engrossed in the everyday work, you do not realize how easily your localization process could be improved. For this reason, it is important to me to show you the following 8 warning signs you should look out for: 1. Waste of timeAre you mailing translation files around the world? Always struggling with this translation files? Other people ask for the resource files to be translated and you hand them out and deep in your mind you know there will be some last minute changes the day before release and even more changes after release. Some time later (days or weeks) some translated files lands in your inbox and you copy them to your repository... But there are already a lot of changes... Some terms are not used anymore others are new and not yet translated and others are modified by the developers in the meanwhile. 2. Waterfall processAre you trying to switch the development process to a more agile approach but the localization process does not fit? Is there no time to translate during the development iteration or sprint? By implementing more SaaS (Software as a Service) products today&#39;s organizations start to introduce CI/CD pipelines (Continuous Integration / Continuous Deployment). Developers focuses on instrumenting the code with the help of some i18n libraries and extract texts into resource files so someone can translate them later. Normally during a development iteration or sprint there is no time to translate the resources. That‚Äôs why some organizations opt to add an extra step to the process after which no text resource may be added, edited, or deleted. This ‚Äúfreeze‚Äù period gives technical writers and translators the necessary time to work. The more text needs to be handled the longer this period while take. This process slows down the release of the software in all languages quite a bit and will result in not really doing a continuous deployment process anymore. 3. Missing contextAre the translated texts too long? Do you feel the translator does not have understood what the product is? By handing over the resource files to the translators, it is very difficult for them to imagine the translated texts in the real product. That&#39;s why very often the translated texts feels wrong when imported back to the product. Doing proper translations needs more information by providing the context or even better by being done incontext. 4. Hard translation managementAre translation texts suddenly deleted while translating? Is the format of the text corrupt after translating? Translators and technical editors are humans too. Not only the lack of technical know how (html or markdown formatting, etc...) but also the power of their tooling is important and crucial. The worse the tooling the greater the danger of getting corrupt texts. 5. Poor integrationDo you wish using the same localization process for your product and other systems simultaneously, like your marketing website? Mostly the product development and the marketing department are split in multiple teams. In that way the localization process evolves in different ways. Not having a central team being responsible for offering internationalization libraries, apis and localization guidelines makes it difficult to find synergies across different products and teams. 6. Locked inDo you have troubles in finding open internationalization libraries compatible with your existing resource files or vice-versa find a localization solution compatible with your internationalization library? Very often the localization process enforces to develop very customized tools and helper scripts if not standardized or at least based on open specifications, formats and protocols. 7. Unclear project progressAre your resource files all fully translated? What is missing? What is the expected effort to complete? Not having a centralized collaborative translation management system that is actively used by developers and translation editors makes it very difficult to forecast when a translation is fully translated and to plan its release. 8. ExpensiveAre your translation orders to expensive? Do you have multiple dedicated personal resources? There is not only the employee salary, but also the wasted time &quot;waiting&quot;, proofreading and correcting the translated resources. And finally, each delay of your time-to-market costs a lot of money. Advice As we learned, localizing software releases is a nightmare and no translation tool really supports product managers, developers and translators well in software translations with continuous changes and additions. Someone started to work on locize.com to bridge the gap between translation and development. Watch the introduction video to learn more. locize removes the pain in the translation process. No more delays in shipping your software because of missing translations. Translator could keep up with changes from day one. The continuous localization process keeps up with your demanding business. Stop waiting - start localizing.","categories":[{"name":"Post","slug":"Post","permalink":"http://blog.locize.com/categories/Post/"}],"tags":[{"name":"locize","slug":"locize","permalink":"http://blog.locize.com/tags/locize/"},{"name":"localization","slug":"localization","permalink":"http://blog.locize.com/tags/localization/"},{"name":"internationalization","slug":"internationalization","permalink":"http://blog.locize.com/tags/internationalization/"}]},{"title":"How locize leverages serverless","slug":"2017-06-22-how-locize-leverages-serverless","date":"2017-06-21T22:00:00.000Z","updated":"2020-01-06T13:59:54.064Z","comments":true,"path":"2017-06-22-how-locize-leverages-serverless/","link":"","permalink":"http://blog.locize.com/2017-06-22-how-locize-leverages-serverless/","excerpt":"","text":"![](title.png \"locize ¬© inweso GmbH\") slides Why we choose serverless? When we started with locize we did not know how fast it would scale‚Ä¶ serverless means we didn‚Äôt need to make that choice. The serverless architecture scales with our business model. The next argument is, we hate maintaining and operating infrastructure. We believe in NoOps. Here serverless saves not only computing power but human resources too. Finally you may ask: Why not a PaaS solution? =&gt; We are working with PaaS solutions since early 2011 and we always had the dream to have a platform where you really pay only when something is used (i.e. call of a function, query of a table, etc‚Ä¶) so you can fully concentrate to the business code. And last but not least: serverless is really cool! Why we choose AWS? We think AWS is the only production-ready FaaS provider (and more) that works out of the box and scales like you expected. It‚Äôs designed with an API-first approach, so everything can be automated. We think AWS has in mind a possible future where you can also run functions directly on the edge (directly on hardware). Additionally AWS has not only lambda but completes the serverless offering with: API Gateway DynamoDB Simple Storage Service (S3) CloudFront Simple Email Service (SES) and a lot more... The basic setup When Developers/Translation Editors/Managers, etc‚Ä¶ goes to www.locize.app, the locize-app-client (which is hosted on S3 and exposed by CloudFront) is served. The client then accesses our lambda backend through the API-Gateway also exposed by CloudFront. Our main working storage (DynamoDB) is then accessed by our lambda functions. Each time someone publishes (or auto-publishes) a translation resource a lambda function will save that resource to S3. When published, the endusers of your product can access them via CDN edge locations offered and exposed by CloudFront too. Full-Stack JavaScript locize is a single language solution! Everything is JavaScript! The complete application backend, the api, the cli and other tools runs on node.js‚Ä¶ and the locize-app-client is a modern SPA based on React and Redux. Lambda functions locize uses 3 different base lambda types. These are not real ‚ÄûAWS-defined‚Äú lambda types but we&#39;ve defined these types ourself. Express The first type is the express type. It defines RESTful APIs using the normal express framework. You see the app.js file looks like a normal express based project. But at the end of the file you see that if this file is executed directly (like node app.js) it will start to listen on port 3000 and can be used to test locally. But if required by another file it exports the configured express app. For this scenario there is an additional file (lambda.js) that uses the help of the npm module ‚Äûaws-serverless-express‚Äú to proxy and map the lambda function calls to http requests and responses. Async The second type is the async type. This lambda function is triggered by other lambda functions to compute non blocking tasks. i.e. calculation of current words in project, or publishing translation resources to S3, etc‚Ä¶ The key element here is that a lambda function is able to call another lambda function by simply using the official aws-sdk npm module. With the help of AWS policies you can define exactly which function can be invoked. S3 event The last type is the S3 event type. This lambda function is i.e. triggered by a new CloudFront log file that was saved to s3 (this feature can be enabled on CloudFront). We use this to i.e. calculate the amount of downloads or to generate statistics. Our tooling Because we have a pure JavaScript landscape we‚Äôve chosen claudia.js It automatically installs and configures a lot on AWS. From API-Gateway to Lambda versioning. Claudia.js does not abstract away AWS services. It‚Äôs really transparent and easy to understand. That‚Äôs why our advice is: if you want to build simple services and run them with AWS lambda, and you&#39;re looking for something low-overhead, easy to get started with, and you only want to use the node.js runtime, Claudia is a good choice.","categories":[{"name":"Post","slug":"Post","permalink":"http://blog.locize.com/categories/Post/"}],"tags":[{"name":"serverless","slug":"serverless","permalink":"http://blog.locize.com/tags/serverless/"},{"name":"backend","slug":"backend","permalink":"http://blog.locize.com/tags/backend/"},{"name":"aws","slug":"aws","permalink":"http://blog.locize.com/tags/aws/"},{"name":"service","slug":"service","permalink":"http://blog.locize.com/tags/service/"}]},{"title":"locizify v2 - improvements","slug":"2017-02-21-locizify-v2","date":"2017-02-20T23:00:00.000Z","updated":"2017-06-23T11:05:30.000Z","comments":true,"path":"2017-02-21-locizify-v2/","link":"","permalink":"http://blog.locize.com/2017-02-21-locizify-v2/","excerpt":"","text":"We use the unpkg CDNIn the past we deployed the locizify script to our own CDN space. While this was ok migrating over to https://unpkg.com allows us to provide you an improved usage. In the past your code was bound to the latest deployed script on our CDN. As we strongly respect semver we just were able to update the script with non breaking updates. Now as you could use the source from unpkg you&#39;re able to fix the version in your code like: 123https:&#x2F;&#x2F;unpkg.com&#x2F;locizify &#x2F;&#x2F; latesthttps:&#x2F;&#x2F;unpkg.com&#x2F;locizify@2.0.1 &#x2F;&#x2F; specific versionhttps:&#x2F;&#x2F;unpkg.com&#x2F;locizify@^2.0.0 &#x2F;&#x2F; latest non breaking version 2.x.x full sample: 1234&lt;script id=&quot;locizify&quot; projectid=&quot;[PROJECT_ID]&quot; apikey=&quot;[API_KEY]&quot; referencelng=&quot;[LNG]&quot; fallbacklng=&quot;[LNG]&quot; saveMissing=&quot;true&quot; src=&quot;https://unpkg.com/locizify@^2.0.0&quot; /&gt; New FeaturesmergingSometimes you want to keep innerHTML of an element together to make it easier to translate. Before: 1&lt;p&gt;Might be easier to translate this &lt;a href=&quot;#&quot;&gt;the new way&lt;/a&gt;&lt;/p&gt; 12345// resulting keys&#123; &quot;Might be easier to translate this &quot;: &quot;Might be easier to translate this &quot;, &quot;the new way&quot;: &quot;the new way&quot;&#125; Using merge: 1&lt;p merge&gt;Might be easier to translate this &lt;a href=&quot;#&quot;&gt;the new way&lt;/a&gt;&lt;/p&gt; 1234// resulting keys&#123; &quot;Might be easier to translate this &lt;a href=&quot;#&quot;&gt;the new way&lt;/a&gt;&quot;: &quot;Might be easier to translate this &lt;a href=&quot;#&quot;&gt;the new way&lt;/a&gt;&quot;&#125; While you can set the merge attribute on every element you like to have this behaviour. You can also specify this globally on init: 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script src=&quot;https://unpkg.com/locizify@^2.0.0&quot;&gt;&lt;/script&gt; &lt;script&gt; locizify.init(&#123; // merging content (eg. a tags in p tags) mergeTags: [], // tags to merge innerHtml to one key inlineTags: [], // tags to inline (eg. a, span, abbr, ...) ignoreInlineOn: [], // tags to ignore inlining tags under inlineTags &#125;); &lt;/script&gt; &lt;/head&gt; ... cleanup for keysWith v2 we improved the key generation from content by removing unused whitespaces: Before: 12345&lt;p&gt; Having text over multiple lines &lt;span&gt; with space in front&lt;/span&gt;&lt;/p&gt; 12345// resulting keys&#123; &quot; Having text/n over multiple lines&quot;: &quot; Having text/n over multiple lines&quot;, &quot; with space in front&quot;: &quot; with space in front&quot;&#125; Using cleanup (default enabled in v2): 12345&lt;p&gt; Having text over multiple lines &lt;span&gt; with space in front&lt;/span&gt;&lt;/p&gt; 12345// resulting keys&#123; &quot;Having text over multiple lines&quot;: &quot;Having text over multiple lines&quot;, &quot;with space in front&quot;: &quot;with space in front&quot;&#125; All the unnecessary whitespaces get removed making translation more easy. You can manually toggle this off or ignore it for certain tags: 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script src=&quot;https://unpkg.com/locizify@^2.0.0&quot;&gt;&lt;/script&gt; &lt;script&gt; locizify.init(&#123; // cleanup for keys cleanIndent: true, // removes indent, eg. if a p tag spans multiple lines ignoreCleanIndentFor: [&#x27;PRE&#x27;, &#x27;CODE&#x27;], // ignores cleaning up of indent for those tags needing that extra spaceing cleanWhitespace: true, // removes surrounding whitespace from key &#125;); &lt;/script&gt; &lt;/head&gt; ... Fragment replacement for links and images12&lt;img src=&quot;/images/&#123;&#123;a.png&#125;&#125;&quot; alt=&quot;big A&quot; /&gt;&lt;a href=&quot;/&#123;&#123;statistic&#125;&#125;&quot;&gt;Open my statistics&lt;/a&gt; You will find a.png and statistic to be a key in your translations - it&#39;s value can be replaced to eg. a-de.png for german (all other languages will fallback to a.png) Translate other then default attributes on elementseg: for validation error messages 1&lt;input data-parsley-error-message=&quot;This field is required&quot; /&gt; Just add data-parsley-error-message to the translateAttributes Array on init: 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script src=&quot;https://unpkg.com/locizify@^2.0.0&quot;&gt;&lt;/script&gt; &lt;script&gt; locizify.init(&#123; translateAttributes: [&#x27;placeholder&#x27;, &#x27;title&#x27;, &#x27;alt&#x27;, &#x27;value#input.type=button&#x27;, &#x27;value#input.type=submit&#x27;], &#125;); &lt;/script&gt; &lt;/head&gt; ... You can define rules like: ``[attributeToTranslate]#element.andOrAttributeWithValue` 123value#input // all values on inputvalue#type // all values on elements having an attribute typevalue#input.type=button // all values on input element having an attribute type set to button Migration from v1To make v2 having the same behaviour as v1 you could change the init options like: 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script src=&quot;https://unpkg.com/locizify@^2.0.0&quot;&gt;&lt;/script&gt; &lt;script&gt; locizify.init(&#123; // cleanup for keys cleanIndent: false, cleanWhitespace: false, ... &#125;); &lt;/script&gt; &lt;/head&gt; ... This way you assert keys get not cleaned of whitespaces so they match the counterpart of v1.","categories":[{"name":"Post","slug":"Post","permalink":"http://blog.locize.com/categories/Post/"}],"tags":[{"name":"locizify","slug":"locizify","permalink":"http://blog.locize.com/tags/locizify/"}]},{"title":"Localization should be fun","slug":"2016-11-16-localization-fun","date":"2016-11-15T23:00:00.000Z","updated":"2017-01-11T13:49:26.000Z","comments":true,"path":"2016-11-16-localization-fun/","link":"","permalink":"http://blog.locize.com/2016-11-16-localization-fun/","excerpt":"","text":"Learn from our experience we made during using the locize service on our own new webapplication. ![](thumb.png \"working hard\") In an early stage of drafting out our plan to completely rewrite our locize webclient we decided to use our own service to manage the content on it. There was no plan on providing it in another language then english - but we strongly believed even not having the demand of translating we could profit of separating the content from the application logic. This way we could go full speed during development while working on final terminology later. As a plus we could change all the texts in production without having to deploy a new client. Another reason was - we wanted to get a better feeling on how the experience is - creating a new project using our service. Our goal was to get a workflow that is faster, less error prone and more fun for everyone being part of the localization process. Our past workflowTo have a comparison with the updated workflow we like to describe how things got done before using locize. If you like to direcly see how things worked with locize just skip this section. Developers path Create a new component, page and get functionality to work Replace all texts with instrumented code (calls to translation function) Add all the new keys to the correct json file (manually resolving the nesting) Restart server to load and serve the new translations files See the json has an error -&gt; fix it -&gt; Restart again See that some keys are still missing -&gt; add -&gt; Restart again Technical editor / Translator path Ask developer for latest resource files Getting them a few days later -&gt; start changing texts to match terminology Save the file and pass it back to development Ask for new texts - getting only a file having all texts -&gt; going crazy as having no idea which stuff is new...start to compare with last file Pass new texts to development ... Poor guys path tries to merge files coming from development and technical editor Goes crazy and starts searching for a new job ;) Doing agile / continuous localization could be hard...you can improve this by doing the steps in waterfall manner: development -&gt; technical editor -&gt; translations. But not only takes this a lot longer but also the problems come back as soon as development starts work on next version having semi-finished texts from the technical editor. Things need to get better - so lets have a look on how our experience was using locize: Having locize in the flow earlyDeveloping new components / pages we directly instrumented the code. In the early stage we still started with having the texts in code and instrument after being functional working. With getting more used to the new workflow we just removed that step and directly used to call the translation function. ![](1_instrument_code.png \"instrumented code\") Using webpacks hot-module-reload feature we just needed to save the file and the webapplication did it&#39;s reload magic: ![](2_trigger_savemissing.png \"save missing was triggered\") This triggered the save missing feature which was enabled during development. So all the untranslated texts were passed automatically to our locize project. Time to reload the new data on our locize project using the new filter &quot;was created by missing&quot; to only show newly submitted texts: ![](3_managecontent.png \"edit content\") Just fill the newly added keys with the content it should have - press save - and done. Reload the application and all the new texts are there: ![](4_done.png \"content loaded from locize\") From here the technical editor / translators could change texts as needed and verify those in the test environment completely independent of the development. Never ask for resource files again Never wait for the new texts / translations to be merged and deployed No need to beg your developers to change a text - not even in production What happened to the poor guy? He was not needed any longer and lost his job before having the chance to search for a new one - just kidding ;) Separating development and content editing made both sides work more efficient, with less errors and a lot faster. Developers, technical editor and translators could work hand in hand without disturbing each others work.","categories":[{"name":"Post","slug":"Post","permalink":"http://blog.locize.com/categories/Post/"}],"tags":[{"name":"locize","slug":"locize","permalink":"http://blog.locize.com/tags/locize/"}]},{"title":"Continuous Development, Integration and Localization => Continuous Deployment","slug":"2016-10-05-continuous-development-integration-and-localization-cd","date":"2016-10-04T22:00:00.000Z","updated":"2020-01-06T13:59:54.064Z","comments":true,"path":"2016-10-05-continuous-development-integration-and-localization-cd/","link":"","permalink":"http://blog.locize.com/2016-10-05-continuous-development-integration-and-localization-cd/","excerpt":"","text":"![](hands_world.jpg \"localization\") Past timesIn the past most organizations that have to write some software planned, developed and released their product in one-year or even multiple-year cycles. =&gt;Typical waterfall process. Every time the developer team had finished implementing the features, the product manager could start to organize and initiate the translation process. So the only thing the developers had to guarantee, was to be able to export and import text resources. That way the texts could be translated all together, by sending them to different agencies or regional market organizations, etc‚Ä¶ When translations were done (after days, weeks or even months), they‚Äôd be sent back to the product manager who forwarded them to the developers. They then had taken the translations, imported and merged them into the product, and (re-)released. Status QuoMost of today‚Äôs organizations are trying to switch the development process to a more agile approach. By implementing more SaaS (Software as a Service) products today‚Äôs organizations start to introduce CI/CD pipelines (Continuous Integration / Continuous Deployment). Developers focuses on instrumenting the code with the help of some i18n libraries like: http://airbnb.io/polyglot.js/ and extract texts into resource files so someone can translate them later. Normally during a development iteration or sprint there is no time to translate the resources, and not just because most people have this sort of attitude: &lt;&lt; We are not interested in the translation process itself. &gt;&gt; That‚Äôs why some organizations opt to add an extra step to the process after which no text resource may be added, edited, or deleted. This ‚Äúfreeze‚Äù period gives technical writers and translators the necessary time to work on. The more text needs to be handled the longer is this period. This process slows down the release of the software in all languages quite a bit and will result in not really doing a continuous deployment. True Continuous Deployment with Continuous LocalizationBecause software development never stops when the first version of a product is released (bug fixes, minor updates and at some point major new versions and releases) ‚Äî continuously. Your localization and translation process should follow the same pattern as your software development. You should be able to deploy your translation files separated from your software so you can update and manage them independently. And if you do so, you have to make sure you can have more then one version of your translations; at least one for the current released version and one for the current development branch. That way your technical writers and translators can take care of the translations from the first day and keep up with changes with ease. By doing this it is even possible to change or add translations without shipping a new release of your software! Cool, but isn‚Äôt this a little over the top‚Ä¶ an extra tooling and deployment ‚Äî doesn‚Äôt all this just add more complexity and effort? You don‚Äôt have to build this yourself!!! ‚Äî There is locize ...give it a try: Register!","categories":[{"name":"Post","slug":"Post","permalink":"http://blog.locize.com/categories/Post/"}],"tags":[{"name":"locize","slug":"locize","permalink":"http://blog.locize.com/tags/locize/"},{"name":"localization","slug":"localization","permalink":"http://blog.locize.com/tags/localization/"},{"name":"internationalization","slug":"internationalization","permalink":"http://blog.locize.com/tags/internationalization/"},{"name":"i18next","slug":"i18next","permalink":"http://blog.locize.com/tags/i18next/"},{"name":"polyglot","slug":"polyglot","permalink":"http://blog.locize.com/tags/polyglot/"},{"name":"formatjs","slug":"formatjs","permalink":"http://blog.locize.com/tags/formatjs/"},{"name":"continuous development","slug":"continuous-development","permalink":"http://blog.locize.com/tags/continuous-development/"},{"name":"continuous integration","slug":"continuous-integration","permalink":"http://blog.locize.com/tags/continuous-integration/"},{"name":"continuous localization","slug":"continuous-localization","permalink":"http://blog.locize.com/tags/continuous-localization/"},{"name":"continuous delivery","slug":"continuous-delivery","permalink":"http://blog.locize.com/tags/continuous-delivery/"},{"name":"continuous translation","slug":"continuous-translation","permalink":"http://blog.locize.com/tags/continuous-translation/"}]},{"title":"The freedom of choice‚Ä¶i18next, polyglot or formatJS","slug":"2016-08-18-the-freedom-of-choice","date":"2016-08-17T22:00:00.000Z","updated":"2020-01-06T13:59:54.063Z","comments":true,"path":"2016-08-18-the-freedom-of-choice/","link":"","permalink":"http://blog.locize.com/2016-08-18-the-freedom-of-choice/","excerpt":"","text":"![](idea.jpg \"locize flexibility\") When we started work on locize.com our localization as a service platform we basically had in mind to solve the translation process for developers using our i18n framework i18next.com. Translation Management Systems are a great help. But still there is a gap between development and translation process. Files need to be exported / imported / merged and all while new content get added to be translated. The chaos is inevitable. locize.com comes to the rescue. It‚Äôs like a translation service on steroid directly connected to your i18next instrumented webproject. (i18next) A few weeks after the successful beta launch and adding a lot of third party services to order translations directly out of your locize project, we started wondering if we could also bring the awesomeness to other frontend internationalization frameworks like airbnb‚Äôs polyglot or yahoo‚Äôs formatJS? polyglot + locize.comOur first look at polyglot revealed that the implementation is rather similar to the i18next json format only the plurals are stored in a single key and separated by ||||. We decided to do a short spike using a node.js express server loading the resources from locize.com using its API and return a demo page using polyglot to translate it. Using request to load the translations: 123456function load(lng, callback) &#123; var url = &#x27;https://api.locize.app/[YOUR_PROJECT_ID]/latest/&#123;&#123;lng&#125;&#125;/translation&#x27;.replace(&#x27;&#123;&#123;lng&#125;&#125;&#x27;, lng); request(url, function(err, res, body) &#123; callback(err, lng, body); &#125;);&#125; The JSON we load from the locize project looks like: https://api.locize.app/897381a6-125c-40b8-9b28-2f80ae9a3612/latest/en/translation 123456789&#123; &quot;interpolate&quot;: &quot;Hello, %&#123;name&#125;.&quot;, &quot;intro&quot;: &quot;The locize.com platform is fully compatible with airbnb‚Äôs polyglot i18n module.&quot;, &quot;plural&quot;: &quot;%&#123;smart_count&#125; car |||| %&#123;smart_count&#125; cars&quot;, &quot;something&quot;: &#123; &quot;nested&quot;: &quot;Nested value something.nested&quot; &#125;, &quot;title&quot;: &quot;Using polyglot with locize.com&quot;&#125; We return a html file injecting the loaded json when requesting the root: 1234567891011app.get(&#x27;/&#x27;, function(req, res) &#123; var lng = req.query.lng || &#x27;en&#x27;; fs.readFile(__dirname + &#x27;/index.html&#x27;, (err, data) =&gt; &#123; if (err) console.log(err); data = data.toString().replace(&#x27;###locals###&#x27;, JSON.stringify(locals[lng])).replace(&#x27;###lng###&#x27;, lng); res.set(&#x27;content-type&#x27;, &#x27;text/html&#x27;); res.send(data); &#125;);&#125;); In the html we basically use polyglot as described on it‚Äôs website: 1234567&lt;script&gt; // initialize polyglot by settings phrases on server var polyglot = new Polyglot(&#123; phrases: JSON.parse(&#x27;###locals###&#x27;), locale: &#x27;###lng###&#x27; &#125;); // translate document.getElementById(&#x27;headline&#x27;).innerHTML = polyglot.t(&#x27;title&#x27;); ...&lt;/script&gt; You can checkout this example on github: https://github.com/locize/locize-polyglot-example. While it is a very basic sample the main focus stays on proving just that you can profit from using locize.com using polyglot. Adapt the sample to your backend language or just use xhr directly to load the data inside your client. You directly benefit from the same benefits just i18next developers had until now using locize.com. formatJS + locize.comformatJS is well known for using the intl API to parse dates and numbers plus uses the ICU message format for translations. The format is rather different from what was used in i18next, but still it‚Äôs just keybased json. So we started from what we did with polyglot. For the backend there was no change needed, so just scroll up to the polyglot sample where we use request o load the translations. The JSON we load from the locize project looks like: https://api.locize.app/9ac4fb1f-be22-4028-bcbc-0da13010b35e/latest/en/translation 123456&#123; &quot;interpolate&quot;: &quot;Hello, &#123;name&#125;.&quot;, &quot;intro&quot;: &quot;The locize.com platform is fully compatible with yahoo&#x27;s format.js i18n module.&quot;, &quot;plural&quot;: &quot;You have &#123;numPhotos, plural, =0 &#123;no photos.&#125;=1 &#123;one photo.&#125;other &#123;# photos.&#125;&#125;&quot;, &quot;title&quot;: &quot;Using format.js with locize.com&quot;&#125; In the html we use the IntlMessageFormat module and created a little helper function 1234567891011121314&lt;script&gt; // initialize var resources = JSON.parse(&#x27;###locals###&#x27;); var lng = &#x27;###lng###&#x27;; // translation helper function t(key, opts) &#123; opts = opts || &#123;&#125;; var m = new IntlMessageFormat(resources[key], lng); return m.format(opts); &#125; // translate document.getElementById(&#x27;headline&#x27;).innerHTML = t(&#x27;title&#x27;); ...&lt;/script&gt; You can see the full example on github: https://github.com/locize/locize-formatjs-example. The sample can easily be adapted to react-intl, ember-intl, handlebars-intl, dust-intl or any other framework using icu messageformat like eg. https://github.com/messageformat/messageformat.js. ConclusionWhile initially focused on i18next json format when building locize.com we found out that you can profit from the locize.com service using polyglot or any libary using messageformat (formatJS and others) too. We love flexibility so we‚Äôre looking forward to our first customer creating a project using airbnb‚Äôs or yahoo‚Äôs i18n framework.","categories":[{"name":"Post","slug":"Post","permalink":"http://blog.locize.com/categories/Post/"}],"tags":[{"name":"locizify","slug":"locizify","permalink":"http://blog.locize.com/tags/locizify/"},{"name":"locize","slug":"locize","permalink":"http://blog.locize.com/tags/locize/"},{"name":"i18next","slug":"i18next","permalink":"http://blog.locize.com/tags/i18next/"},{"name":"polyglot","slug":"polyglot","permalink":"http://blog.locize.com/tags/polyglot/"},{"name":"formatjs","slug":"formatjs","permalink":"http://blog.locize.com/tags/formatjs/"}]},{"title":"how we eat our own dogfood","slug":"2016-06-11-eat-our-own-dogfood","date":"2016-06-10T22:00:00.000Z","updated":"2021-04-07T14:33:18.411Z","comments":true,"path":"2016-06-11-eat-our-own-dogfood/","link":"","permalink":"http://blog.locize.com/2016-06-11-eat-our-own-dogfood/","excerpt":"","text":"After relaunching our website with new templates for our documentation, post pages and adding a new landing page, we decided to have at least the landing page translated. As we use hexo to generate our static content it was just a natural fit to use our locizify script so we don&#39;t have to instrument the page ourself. As we might add other areas later we decided to have a fixed namespace (filename) for the landing page. We used the advanced option to init locizify like described here. We ended with following snipplet: 123456789101112131415161718&lt;script src=&quot;https://unpkg.com/locizify@^2.0.0&quot;&gt;&lt;/script&gt;&lt;script&gt; locizify.init(&#123; namespace: &#x27;landingpage&#x27;, saveMissing: true, fallbackLng: &#x27;en&#x27;, backend: &#123; projectId: &#x27;3d0aa5aa-4660-4154-b6d9-907dbef10bb2&#x27;, apiKey: &#x27;******** private ********&#x27;, referenceLng: &#x27;en&#x27;, version: &#x27;production&#x27; &#125;, // ignore some dynamic widgets ignoreIds: [&#x27;nudgespotInappContainer&#x27;, &#x27;nudgespotInappMessagesContainer&#x27;, &#x27;nudgespotInappConversationsContainer&#x27;, &#x27;__bs_notify__&#x27;], ignoreClasses: [&#x27;nudgespot-clean&#x27;] &#125;);&lt;/script&gt; After reloading the page we had the source content in english inside our project. We translated that to german and italian in no time using our editor. ![](translate.png \"translate to german\") As the latest version gets auto published reloading the page with the additional querystring parameter ?lng=de (or switching browser language) was enough to test the translation. Next we created a production version (going to project settings -&gt; versions) so we can change or prepare new content during development without messing with the currently released page version. ![](version.png \"translate to german\") After that we wanted to avoid the flickering on initial load where the page first gets displayed in the source language until locizify loaded and initial translated the page. To optimize this we just needed to add display: none to body (more info): 1&lt;body style=&quot;display: none&quot;&gt; Finally we needed a solution to let the user change the language on our page. We started with a simple list of links: 12345&lt;ul&gt; &lt;a href=&quot;/?lng=en&quot;&gt;english&lt;/a&gt; &lt;a href=&quot;/?lng=de&quot;&gt;deutsch&lt;/a&gt; &lt;a href=&quot;/?lng=it&quot;&gt;italiano&lt;/a&gt;&lt;/ul&gt; But decided a select element would fit more to our current layout. We needed to add binding to i18next changeLanguage event to select current language and handle the select onChange event. Further we use locizify.getLanguages to get current available languages in our project, so we don&#39;t have to touch the code when we add new languages: the select element: 12&lt;select id=&quot;languageSelect&quot; onChange=&quot;handleSelectChange()&quot; translated&gt;&lt;/select&gt; the script: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// the select elementvar ele = document.getElementById(&#x27;languageSelect&#x27;);var availableLngs = [];// create select options based on project languageslocizify.getLanguages(function(err, lngs) &#123; availableLngs = Object.keys(lngs || &#123;&#125;); availableLngs.forEach(function(l) &#123; var lng = lngs[l]; // return if not at least 90% is translated if (lng.translated.production &lt; 0.9) return; // append ele var optEle = document.createElement(&quot;OPTION&quot;); optEle.setAttribute(&#x27;value&#x27;, l); optEle.innerHTML = lng.nativeName; ele.appendChild(optEle); &#125;); updateSelect();&#125;);// selects the value based on i18next lngsfunction updateSelect() &#123; var selected; locizify.i18next.languages.forEach(function(l) &#123; if (!selected &amp;&amp; availableLngs.indexOf(l) &gt; -1) selected = l; &#125;); ele.value = selected || &#x27;en&#x27;;&#125;// reload page on selectionfunction handleSelectChange() &#123; var value = ele.options[ele.selectedIndex].value; window.location = updateQueryStringParameter(window.location.href, &#x27;lng&#x27;, value);&#125;// bind i18next change language eventlocizify.i18next.on(&#x27;languageChanged&#x27;, function(lng) &#123; updateSelect();&#125;);// just a helper to update uri with new paramsfunction updateQueryStringParameter(uri, key, value) &#123; var re = new RegExp(&quot;([?&amp;])&quot; + key + &quot;=.*?(&amp;|$)&quot;, &quot;i&quot;); var separator = uri.indexOf(&#x27;?&#x27;) !== -1 ? &quot;&amp;&quot; : &quot;?&quot;; if (uri.match(re)) &#123; return uri.replace(re, &#x27;$1&#x27; + key + &quot;=&quot; + value + &#x27;$2&#x27;); &#125; else &#123; return uri + separator + key + &quot;=&quot; + value; &#125;&#125; That&#39;s all. Our project was translated in no time including a custom language selector: ![](result.png \"translated to german\") We are very pleased with the outcome of eating our own dogfood. Next step will be to order professional translations for the languages we can&#39;t translate ourself...","categories":[{"name":"Post","slug":"Post","permalink":"http://blog.locize.com/categories/Post/"}],"tags":[{"name":"locizify","slug":"locizify","permalink":"http://blog.locize.com/tags/locizify/"},{"name":"locize","slug":"locize","permalink":"http://blog.locize.com/tags/locize/"}]},{"title":"technology stack - locize is serverless","slug":"2016-04-07-technology-stack","date":"2016-04-06T22:00:00.000Z","updated":"2016-11-10T07:17:23.000Z","comments":true,"path":"2016-04-07-technology-stack/","link":"","permalink":"http://blog.locize.com/2016-04-07-technology-stack/","excerpt":"","text":"No Servers?We believe that the best DevOps is NoOps. Nothing against DevOps or DevOps people. On the contrary, but we think we could do differently! Instead of spending time on setting up virtual machines and maintaining them, we setup our stack directly on different services ‚Äì leaving ourselves more time to work on great features. locize gave us a chance to have a look around at new paths for building long lasting components. We used a set of AWS solutions: AWS DynamoDB AWS CloudFront CDN AWS Simple Storage Service S3 but specifically: AWS API Gateway AWS Lambda Amazon LambdaAWS Lambda is a compute service where you can upload your code to AWS Lambda and the service can run the code on your behalf using AWS infrastructure. All this without the hassle of own virtual machines, containers or any infrastructure for that matter. It integrates very well with S3 (where we serve the localized files) and with DynamoDB (our main work storage). We don‚Äôt have to worry about scaling, multi-server communication and other problems related to distributed systems. We use the node.js runtime for all our lambda functions. Amazon API GatewayAWS API Gateway lets you create a RESTful API to expose selected back-end features. The back end can be another AWS service, such as AWS Lambda or AWS DynamoDB, or it can be an existing web application. Below you can see how locize uses this services What about the client side?In an other blog post ;-)","categories":[{"name":"Post","slug":"Post","permalink":"http://blog.locize.com/categories/Post/"}],"tags":[{"name":"backend","slug":"backend","permalink":"http://blog.locize.com/tags/backend/"},{"name":"aws","slug":"aws","permalink":"http://blog.locize.com/tags/aws/"},{"name":"service","slug":"service","permalink":"http://blog.locize.com/tags/service/"},{"name":"technology","slug":"technology","permalink":"http://blog.locize.com/tags/technology/"}]},{"title":"day zero - how all began","slug":"2016-02-27-day-zero","date":"2016-02-26T23:00:00.000Z","updated":"2016-11-10T07:17:23.000Z","comments":true,"path":"2016-02-27-day-zero/","link":"","permalink":"http://blog.locize.com/2016-02-27-day-zero/","excerpt":"","text":"Back in 2011All started back in 2011 when we were in search for a internationalization library that meets our demand - allowing to run both on serverside node.js and on our clientside singlepage applications. I18next was born and fastly grown to one of the most used frameworks for translating webapplications and in node.js. The response of the community was amazing and a fast growing ecosystem established itself around i18next. internationalization is not enoughOur community provided us with great feedback. Out of that response and our own experiences we learnt providing instrumentation for doing proper internationalization just is not enough. Helping developers to get their applications translated is great - but there is more to it. How do you integrate any translation services / agency? How do you keep track of new or removed content? How you handle proper versioning? How you deploy translation changes without deploying your complete application? locize to the rescueHaving created the foundation with i18next it was a long journey to localization as a service. But the journey ends this year with locize. Easy to integrate Order professional translations Analytics &amp; Statistics Profit from our content delivery network Versioning of your translations Riskfree: Take your data with you Transparent and fair pricing","categories":[{"name":"Post","slug":"Post","permalink":"http://blog.locize.com/categories/Post/"}],"tags":[{"name":"beginning","slug":"beginning","permalink":"http://blog.locize.com/tags/beginning/"},{"name":"i18next","slug":"i18next","permalink":"http://blog.locize.com/tags/i18next/"}]}],"categories":[{"name":"Post","slug":"Post","permalink":"http://blog.locize.com/categories/Post/"}],"tags":[{"name":"locize","slug":"locize","permalink":"http://blog.locize.com/tags/locize/"},{"name":"localization","slug":"localization","permalink":"http://blog.locize.com/tags/localization/"},{"name":"internationalization","slug":"internationalization","permalink":"http://blog.locize.com/tags/internationalization/"},{"name":"i18next","slug":"i18next","permalink":"http://blog.locize.com/tags/i18next/"},{"name":"translation","slug":"translation","permalink":"http://blog.locize.com/tags/translation/"},{"name":"service","slug":"service","permalink":"http://blog.locize.com/tags/service/"},{"name":"localistars","slug":"localistars","permalink":"http://blog.locize.com/tags/localistars/"},{"name":"order","slug":"order","permalink":"http://blog.locize.com/tags/order/"},{"name":"web","slug":"web","permalink":"http://blog.locize.com/tags/web/"},{"name":"continuous localization","slug":"continuous-localization","permalink":"http://blog.locize.com/tags/continuous-localization/"},{"name":"award","slug":"award","permalink":"http://blog.locize.com/tags/award/"},{"name":"formatjs","slug":"formatjs","permalink":"http://blog.locize.com/tags/formatjs/"},{"name":"continuous development","slug":"continuous-development","permalink":"http://blog.locize.com/tags/continuous-development/"},{"name":"continuous integration","slug":"continuous-integration","permalink":"http://blog.locize.com/tags/continuous-integration/"},{"name":"continuous delivery","slug":"continuous-delivery","permalink":"http://blog.locize.com/tags/continuous-delivery/"},{"name":"continuous translation","slug":"continuous-translation","permalink":"http://blog.locize.com/tags/continuous-translation/"},{"name":"serverless","slug":"serverless","permalink":"http://blog.locize.com/tags/serverless/"},{"name":"backend","slug":"backend","permalink":"http://blog.locize.com/tags/backend/"},{"name":"aws","slug":"aws","permalink":"http://blog.locize.com/tags/aws/"},{"name":"locizify","slug":"locizify","permalink":"http://blog.locize.com/tags/locizify/"},{"name":"polyglot","slug":"polyglot","permalink":"http://blog.locize.com/tags/polyglot/"},{"name":"technology","slug":"technology","permalink":"http://blog.locize.com/tags/technology/"},{"name":"beginning","slug":"beginning","permalink":"http://blog.locize.com/tags/beginning/"}]}